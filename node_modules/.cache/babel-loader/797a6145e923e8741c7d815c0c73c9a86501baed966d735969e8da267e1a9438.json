{"ast":null,"code":"const express = require('express');\nconst app = express();\nconst PORT = 4000;\nconst fs = require(\"fs\");\nconst http = require('http').Server(app);\nconst cors = require('cors');\n\n// Enable CORS\napp.use(cors());\n\n// Define route to fetch messages\napp.get('/api', async (req, res) => {\n  const messages = await ReadData();\n  res.json({\n    messages: messages\n  });\n});\n\n// Initialize socket.io\nconst socketIO = require('socket.io')(http, {\n  cors: {\n    origin: \"*\"\n  }\n});\n\n// Function to write message data to file\nconst writeData = async message => {\n  let messages = await ReadData().catch(err => {\n    console.error(\"Error reading data:\", err);\n    return []; // Default to empty array if read fails\n  });\n  messages.push(message);\n  return new Promise((resolve, reject) => {\n    fs.writeFile(\"message.json\", JSON.stringify(messages, null, 2),\n    // Pretty formatting\n    err => {\n      if (err) {\n        console.error(\"Error writing data:\", err);\n        reject(err);\n      } else {\n        resolve(\"success\");\n        console.log(\"Done writing\");\n      }\n    });\n  });\n};\n\n// Function to read messages from file\nconst ReadData = () => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(\"message.json\", \"utf8\", (err, data) => {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // File doesn't exist, resolve with empty array\n          console.warn(\"message.json not found, creating new file.\");\n          resolve([]);\n        } else {\n          console.error(\"Error reading file:\", err);\n          reject(err);\n        }\n      } else {\n        // Parse the file content\n        try {\n          const messages = JSON.parse(data);\n          resolve(messages);\n        } catch (parseErr) {\n          console.error(\"Error parsing JSON:\", parseErr);\n          resolve([]); // Return empty array on parsing error\n        }\n      }\n    });\n  });\n};\n\n// Socket.io connection handling\n_c = ReadData;\nsocketIO.on('connection', socket => {\n  console.log(`âš¡: ${socket.id} user just connected!`);\n\n  // Join a specific room\n  socket.on('joinRoom', roomId => {\n    socket.join(roomId);\n    console.log(`User with ID: ${socket.id} joined room: ${roomId}`);\n  });\n\n  // Handle incoming messages\n  socket.on('message', data => {\n    const parsedMessage = JSON.parse(data);\n    writeData(parsedMessage).then(() => {\n      // Emit the message to the room instead of all users\n      socket.to(parsedMessage.roomId).emit('messageResponse', parsedMessage);\n    }).catch(err => {\n      console.error('Error writing data:', err);\n    });\n  });\n\n  // Handle user disconnect\n  socket.on('disconnect', () => {\n    console.log('ðŸ”¥: A user disconnected');\n  });\n});\n\n// Start the server\nhttp.listen(PORT, () => {\n  console.log(`Server listening on ${PORT}`);\n});\nvar _c;\n$RefreshReg$(_c, \"ReadData\");","map":{"version":3,"names":["express","require","app","PORT","fs","http","Server","cors","use","get","req","res","messages","ReadData","json","socketIO","origin","writeData","message","catch","err","console","error","push","Promise","resolve","reject","writeFile","JSON","stringify","log","readFile","data","code","warn","parse","parseErr","_c","on","socket","id","roomId","join","parsedMessage","then","to","emit","listen","$RefreshReg$"],"sources":["/Users/hipl/Desktop/newChatbot/ChatFrontend/src/App.js"],"sourcesContent":["const express = require('express');\nconst app = express();\nconst PORT = 4000;\nconst fs = require(\"fs\");\nconst http = require('http').Server(app);\nconst cors = require('cors');\n\n// Enable CORS\napp.use(cors());\n\n// Define route to fetch messages\napp.get('/api', async (req, res) => {\n  const messages = await ReadData();\n  res.json({\n    messages: messages\n  });\n});\n\n// Initialize socket.io\nconst socketIO = require('socket.io')(http, {\n  cors: {\n    origin: \"*\"\n  }\n});\n\n// Function to write message data to file\nconst writeData = async (message) => {\n  let messages = await ReadData().catch((err) => {\n    console.error(\"Error reading data:\", err);\n    return []; // Default to empty array if read fails\n  });\n\n  messages.push(message);\n  return new Promise((resolve, reject) => {\n    fs.writeFile(\n      \"message.json\",\n      JSON.stringify(messages, null, 2), // Pretty formatting\n      (err) => {\n        if (err) {\n          console.error(\"Error writing data:\", err);\n          reject(err);\n        } else {\n          resolve(\"success\");\n          console.log(\"Done writing\");\n        }\n      }\n    );\n  });\n};\n\n// Function to read messages from file\nconst ReadData = () => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(\"message.json\", \"utf8\", (err, data) => {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // File doesn't exist, resolve with empty array\n          console.warn(\"message.json not found, creating new file.\");\n          resolve([]);\n        } else {\n          console.error(\"Error reading file:\", err);\n          reject(err);\n        }\n      } else {\n        // Parse the file content\n        try {\n          const messages = JSON.parse(data);\n          resolve(messages);\n        } catch (parseErr) {\n          console.error(\"Error parsing JSON:\", parseErr);\n          resolve([]); // Return empty array on parsing error\n        }\n      }\n    });\n  });\n};\n\n// Socket.io connection handling\nsocketIO.on('connection', (socket) => {\n  console.log(`âš¡: ${socket.id} user just connected!`);\n\n  // Join a specific room\n  socket.on('joinRoom', (roomId) => {\n    socket.join(roomId);\n    console.log(`User with ID: ${socket.id} joined room: ${roomId}`);\n  });\n\n  // Handle incoming messages\n  socket.on('message', (data) => {\n    const parsedMessage = JSON.parse(data);\n    writeData(parsedMessage)\n      .then(() => {\n        // Emit the message to the room instead of all users\n        socket.to(parsedMessage.roomId).emit('messageResponse', parsedMessage);\n      })\n      .catch((err) => {\n        console.error('Error writing data:', err);\n      });\n  });\n\n  // Handle user disconnect\n  socket.on('disconnect', () => {\n    console.log('ðŸ”¥: A user disconnected');\n  });\n});\n\n// Start the server\nhttp.listen(PORT, () => {\n  console.log(`Server listening on ${PORT}`);\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}